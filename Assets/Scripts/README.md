# 퍼즐 게임 모작

## 맵
크기 : RxC 직사각형, 구멍 뚫린 직사각형, 크기가 다른 직사각형의 결합, 이 외에도 여러 모양 보유

## 블록
### 일반 블록
R, G, B, Y의 4가지 색상의 직사각형 블록
2개 이상이 맞닿아있는 경우 폭파 가능, 5개 이상의 블록이 닿은 경우 깬 위치에 특수 블록 생성 가능

### 특수 블록
5,6개 폭파 : 행/열을 전부 파괴하는 특수 블록 생성 (행,열의 구분 방식은 미정)
7,8개 폭파 : 폭탄 (주변 8개의 블록 폭파)
9개 이상 폭파 : 꽃 (해당 색상의 블록을 전부 파괴)

특수 블록이 맞닿아서 폭파될 경우 시너지 발동

### 목표 블록
땅에 닿아야 사라지는 블록 : 중력 영향 받음, 주변의 폭파에도 파괴되지 않음
위치가 고정된 블록 : 중력 영향 받지 않음, 주변의 폭파로 인해 파괴됨
방울 블록 : 일반 블록에 방울이 씌워짐. 중력에 영향을 받으며 주변의 폭파로 파괴됨
카운트 블록 : 중력 영향 안받음. 주변 폭파에도 파괴되지 않음. 다만 주변 폭파의 카운트를 세서 목표에 도달하는지를 검사함

### 블록 폭파 로직
1. Collider에 MouseDown함수를 통해 블록이 클릭될 경우 폭파 로직을 실행
2. 해당 블록의 타입에 따라 특수 블록일 경우 Special Explode, 일반 블록일 경우 3개 이상의 인접한 블록인 경우 Explode를 실행

#### Special Explode
특수 블록 폭파는 우선 해당 블록의 타입을 구분하여 폭파를 진행한다. 수직/수평 특수 블록은 해당 행/열을 지우는 블록이므로
반복문을 통해 해당되는 행/열을 지우도록 한다.
이 때, m_Board의 GameOjbect 2차원 배열을 탐색하는데 [r, c]의 값이 null을 참조하면 continue를 하고 일반 블록을 참조하는 경우 혹은
클릭한 블록을 (특수 블록) 참조하는 경우에는 일반 폭발을 진행시킨다.
- 일반 폭발의 과정
1. Coord_list라는 좌표를 저장하는 리스트에 폭파되는 블록의 좌표를 저장한다.
2. m_Board[r,c]가 참조하는 블록을 초기화하고 BlockPool로 다시 push한다.
3. m_Board[r,c] = null 로 초기화한다.

일반 폭파는 이렇게 진행되고 만약 특수 블록이 존재하는 경우에는 q_coord라는 좌표를 저장하는 큐 자료구조에 추가시키고 폭파는 진행하지 않는다.
이후, FillBlock(dir) 함수를 호출하여 Coord_list에 저장한 좌표에 새로운 블록을 추가하고 기존 블록과 함께 dir 방향대로 이동시키는 로직을 실행한다.
FillBlock이 끝난 이후 Coord_list를 clear하고 아까 q_coord에 몰아뒀던 특수 블록 좌표 큐를 비우며 ExplodeSpecial 함수를 재귀로 호출한다.

### FillBlock(dir)
SortedSet에 Row, Col을 저장한다. -> 이는 행/열 기준으로 어떤 블록이 더 많은지를 조회하여 Vertical, Horizontal을 결정하는 변수가 된다.
이후 클릭된 블록의 방향 즉 dir을 switch문으로 구분하며 이동을 진행시킨다. m_Board[r,c]가 null이라면 q라는 좌표를 저장하는 큐에 해당 좌표를 추가한다.
만약 특수 블록이 발견된다면 continue를 진행하고, 보드의 참조값이 null도 아니고 특수 블록도 아닌 경우 -> 일반 블록인 경우 + q가 비어있지 않은 경우에는 이동을 시작한다.
즉 q는 이동해야하는 블록의 좌표를 저장하는 큐인 것이다. 비어있는 좌표를 채워야하니 이를 저장한 것이고 일반 블록이 보이더라도 q가 비어있다는 것은
앞의 블록들이 비어있지 않으므로 이동할 필요가 없다는 의미이다.
q.Count != 0 인 경우, q의 값을 pop해서 블록의 MoveBlock 메소드에 위치를 보낸다. 그리고 m_Board의 값을 swap해주고 다시 q에 비어 있는 좌표를 추가한다.

이 과정이 끝난 이후에 q가 비어있지 않다면 -> 현존하는 블록을 이동시켜 앞의 구멍을 메웠지만 뒤의 구멍은 비어있는 경우. 새로운 블록을 가져와서 채워넣게 된다.
q를 while문으로 빌 때까지 반복하여 위와 같이 이동시키는 로직을 진행한다.

## 버그 리포트
1. 특수 블록이 이동하지 않는 버그
특수 블록 주변의 다른 블록이 파괴되더라도, 해당 블록은 이동하지 않은 채 다른 블록들만 이동하여 빈 자리를 메꾸는 경우 발생.
FillBlock의 
else if (m_Board[r, c].GetComponent<BlockScript>().Type != BlockScript.BLOCK_TYPE.NORMAL) continue;
조건 때문에 발생..
하지만 이를 없앨 경우 연쇄 파괴가 발생하지 않게 됨.
=> 이는 특수 블록을 일반 파괴 과정에서 이동시킬지, 말지를 결정하는 문제에서 발생한다. 즉, 위의 조건문으로 특수 블록의 이동 자체를 막아버리면 어떤 이동에서도 면역이 생기므로
잘못된 로직에 해당한다. 그렇다면 이런 조건문을 왜 추가했을까? 그건 연쇄폭파 때문이다. 그럼 왜 연쇄 폭파가 위의 조건문이 없는 경우에는 작동하지 않았는가?
그 이유는 SpecialExplode 당시 FillBlock이 끝난 후 q_coord를 순회하며 이전에 추가했던 특수 블록의 폭파를 재귀적으로 진행하는데, 이미 "좌표"의 위치가 변화한 특수 블록이기 때문에
로직이 발생하지 않았던 것이다.. 어찌보면 블록 객체 자체를 참조하도록 구현한 것이 아닌 단순한 좌표를 저장했으니 FillBlock 함수를 통해 이동해버린 블록을 추적하는 것이 불가능하기에
이런 사태가 발생한 것이다.

그럼 어떻게 해결을 할 수 있을까, 위에서 말했듯이 우선 위의 조건문은 전부 다 삭제해야한다.
1. 폭발하는 블록을 좌표가 아닌 참조를 통해 저장한다.
2. q_coord가 아닌 다시 전체 순회
정도의 대안이 떠오르는데, 그냥 q_coord를 좌표가 아닌 GameObject의 레퍼런스를 담는 q_block을 추가해서 구현하니 연쇄 폭파, 특수 블록의 이동 모두 해결됐다.

하지만 의도한 대로 작동하지 않았는데 다시 발생한 문제는, 2차 폭파하는 특수 블록의 경우 기존의 위치한 곳에서의 폭파가 아닌
1차 폭파에 의해 옮겨진 장소에서 폭파가 이루어지는 점 이었다.
물론 이건 기획의도가 그러했다고 볼 수도 있다. 1차 폭파로 이동될 위치에서 특수 폭파가 이어진다는 flow는 결코 나쁘다고 볼 순 없을 것 같다.








## 아이템
드릴 : 특정 블록 하나를 파괴
행 : 행 하나를 파괴
열 : 열 하나를 파괴
주사위 : 모든 블록을 섞음


### 특수 블록 생성 및 파괴 로직
1. n개 이상 연결된 블록 파괴 시, 해당 블록을 특수 블록으로 변환 후 위치 이동 및 새로운 블록 할당
2. 특수 블록 파괴 시 새로운 블록 파괴 함수 실행

일반 블록의 연결된 수를 기반으로 

### 스테이지
n개 이상 연결된 블록 덩어리를 만들어라 -> 심화 버전 n번의 파괴 이내로 or m개 색상의 블록 종류 조건 추가

